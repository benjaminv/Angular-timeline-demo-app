{"ast":null,"code":"'use strict';\n\nvar _firstTarget = null; // singleton, will contain the target element where the touch event started\n\n/**\n * Extend an Hammer.js instance with event propagation.\n *\n * Features:\n * - Events emitted by hammer will propagate in order from child to parent\n *   elements.\n * - Events are extended with a function `event.stopPropagation()` to stop\n *   propagation to parent elements.\n * - An option `preventDefault` to stop all default browser behavior.\n *\n * Usage:\n *   var hammer = propagatingHammer(new Hammer(element));\n *   var hammer = propagatingHammer(new Hammer(element), {preventDefault: true});\n *\n * @param {Hammer.Manager} hammer   An hammer instance.\n * @param {Object} [options]        Available options:\n *                                  - `preventDefault: true | false | 'mouse' | 'touch' | 'pen'`.\n *                                    Enforce preventing the default browser behavior.\n *                                    Cannot be set to `false`.\n * @return {Hammer.Manager} Returns the same hammer instance with extended\n *                          functionality\n */\n\nexport default function propagating(hammer, options) {\n  var _options = options || {\n    preventDefault: false\n  };\n\n  if (hammer.Manager) {\n    // This looks like the Hammer constructor.\n    // Overload the constructors with our own.\n    var Hammer = hammer;\n\n    var PropagatingHammer = function (element, options) {\n      var o = Object.create(_options);\n      if (options) Hammer.assign(o, options);\n      return propagating(new Hammer(element, o), o);\n    };\n\n    Hammer.assign(PropagatingHammer, Hammer);\n\n    PropagatingHammer.Manager = function (element, options) {\n      var o = Object.create(_options);\n      if (options) Hammer.assign(o, options);\n      return propagating(new Hammer.Manager(element, o), o);\n    };\n\n    return PropagatingHammer;\n  } // create a wrapper object which will override the functions\n  // `on`, `off`, `destroy`, and `emit` of the hammer instance\n\n\n  var wrapper = Object.create(hammer); // attach to DOM element\n\n  var element = hammer.element;\n  if (!element.hammer) element.hammer = [];\n  element.hammer.push(wrapper); // register an event to catch the start of a gesture and store the\n  // target in a singleton\n\n  hammer.on('hammer.input', function (event) {\n    if (_options.preventDefault === true || _options.preventDefault === event.pointerType) {\n      event.preventDefault();\n    }\n\n    if (event.isFirst) {\n      _firstTarget = event.target;\n    }\n  });\n  /** @type {Object.<String, Array.<function>>} */\n\n  wrapper._handlers = {};\n  /**\n   * Register a handler for one or multiple events\n   * @param {String} events    A space separated string with events\n   * @param {function} handler A callback function, called as handler(event)\n   * @returns {Hammer.Manager} Returns the hammer instance\n   */\n\n  wrapper.on = function (events, handler) {\n    // register the handler\n    split(events).forEach(function (event) {\n      var _handlers = wrapper._handlers[event];\n\n      if (!_handlers) {\n        wrapper._handlers[event] = _handlers = []; // register the static, propagated handler\n\n        hammer.on(event, propagatedHandler);\n      }\n\n      _handlers.push(handler);\n    });\n    return wrapper;\n  };\n  /**\n   * Unregister a handler for one or multiple events\n   * @param {String} events      A space separated string with events\n   * @param {function} [handler] Optional. The registered handler. If not\n   *                             provided, all handlers for given events\n   *                             are removed.\n   * @returns {Hammer.Manager}   Returns the hammer instance\n   */\n\n\n  wrapper.off = function (events, handler) {\n    // unregister the handler\n    split(events).forEach(function (event) {\n      var _handlers = wrapper._handlers[event];\n\n      if (_handlers) {\n        _handlers = handler ? _handlers.filter(function (h) {\n          return h !== handler;\n        }) : [];\n\n        if (_handlers.length > 0) {\n          wrapper._handlers[event] = _handlers;\n        } else {\n          // remove static, propagated handler\n          hammer.off(event, propagatedHandler);\n          delete wrapper._handlers[event];\n        }\n      }\n    });\n    return wrapper;\n  };\n  /**\n   * Emit to the event listeners\n   * @param {string} eventType\n   * @param {Event} event\n   */\n\n\n  wrapper.emit = function (eventType, event) {\n    _firstTarget = event.target;\n    hammer.emit(eventType, event);\n  };\n\n  wrapper.destroy = function () {\n    // Detach from DOM element\n    var hammers = hammer.element.hammer;\n    var idx = hammers.indexOf(wrapper);\n    if (idx !== -1) hammers.splice(idx, 1);\n    if (!hammers.length) delete hammer.element.hammer; // clear all handlers\n\n    wrapper._handlers = {}; // call original hammer destroy\n\n    hammer.destroy();\n  }; // split a string with space separated words\n\n\n  function split(events) {\n    return events.match(/[^ ]+/g);\n  }\n  /**\n   * A static event handler, applying event propagation.\n   * @param {Object} event\n   */\n\n\n  function propagatedHandler(event) {\n    // let only a single hammer instance handle this event\n    if (event.type !== 'hammer.input') {\n      // it is possible that the same srcEvent is used with multiple hammer events,\n      // we keep track on which events are handled in an object _handled\n      if (!event.srcEvent._handled) {\n        event.srcEvent._handled = {};\n      }\n\n      if (event.srcEvent._handled[event.type]) {\n        return;\n      } else {\n        event.srcEvent._handled[event.type] = true;\n      }\n    } // attach a stopPropagation function to the event\n\n\n    var stopped = false;\n\n    event.stopPropagation = function () {\n      stopped = true;\n    }; //wrap the srcEvent's stopPropagation to also stop hammer propagation:\n\n\n    var srcStop = event.srcEvent.stopPropagation.bind(event.srcEvent);\n\n    if (typeof srcStop == \"function\") {\n      event.srcEvent.stopPropagation = function () {\n        srcStop();\n        event.stopPropagation();\n      };\n    } // attach firstTarget property to the event\n\n\n    event.firstTarget = _firstTarget; // propagate over all elements (until stopped)\n\n    var elem = _firstTarget;\n\n    while (elem && !stopped) {\n      var elemHammer = elem.hammer;\n\n      if (elemHammer) {\n        var _handlers;\n\n        for (var k = 0; k < elemHammer.length; k++) {\n          _handlers = elemHammer[k]._handlers[event.type];\n          if (_handlers) for (var i = 0; i < _handlers.length && !stopped; i++) {\n            _handlers[i](event);\n          }\n        }\n      }\n\n      elem = elem.parentNode;\n    }\n  }\n\n  return wrapper;\n}\n;","map":null,"metadata":{},"sourceType":"module"}